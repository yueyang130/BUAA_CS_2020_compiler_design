## 语法解读
1. 区分<整数>和<无符号整数>
2. 区分'['无符号整数']'和'['表达式']'
3. ＜语句列＞   ::= ｛＜语句＞｝, 这里的{}指的是0到无穷个，不是'{'


## 代码
1. 类似 ＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞ 的逻辑
<常量说明>的first与后面两个不交叉
<变量声明>的first与<语句列>不交叉
代码如下：
	// 两个if是并列的
	if (equal(symbolType::CONSTTK)) {
			ConstDeclare();
		}
	if (equal(symbolType::INTTK, symbolType::CHARTK)) {
		VarDeclare();
	}
	StatetmentList();

## 错误
1. vector的元素类型不能是引用，因为引用必须在定义时初始化。
2. 不能使用不完整的类型的意思是：没有include对应的头文件。
3. 类的非静态方法一般不能作为函数指针，因为它有一个隐藏参数this，还要解决继承等问题。要使用类成员函数指针。
		(void(GrammerAnalyzer::*handler)(symbolType) = &GrammerAnalyzer::ConstValue;  // 取函数指针 
		(obj/this->*handler)(var_type); // 使用函数指针
4. 与Java不同，使用类的静态方法时，不能使用.运算符，要使用::运算符。
5.在C语言中，定义结构体:
	typedef strcut {
		...
	} A;
而在C++中，不需要使用typedef,而且将结构体名放在前面。
	struct A {
		...
	};

6. C++的多态是依赖指针和引用实现的；不能直接将继承类的对象赋值给基类对象，会产生“剪切”。

7. 向下传播时，static_cast（用于基础变量和一般指针）/static_pointer_cast(用于智能指针)不进行动态检查，可能产生错误。
	dynamic_cast/dynamic_pointer_cast进行动态检查。但基类中必须有virtual method(将虚构函数设为virtual即可)

8.  make_shared<T>()并不是返回空指针，而是调用T的默认构造函数构造对象。
	使用shared_ptr<T>()得到空指针。

9. switch语句报错：控制传输跳过的实例化
原因：在case语句中声明了变量
解决方法：用大括号来表明变量的作用域

10. duplicate symbol
原因：在头文件中写函数定义。虽然有#ifndef，但是宏定义的作用域是当前文件。出了当前文件，宏就失效了。
因此仍然存在重复定义的可能。	
解决方法:不要在头文件中写函数定义。

11.向顺序容器插入元素可能会使所有指向容器的**迭代器，引用和指针**失效
因此如果在对顺序容器中的某个元素的使用过程中**有插入元素的行为**。最好直接通过下标寻址，或者copy这个元素。
不要通过指针，引用(其实就是const指针)，迭代器来访问这个元素。

12. vector.insert(p,q) 是insert到迭代器p之前，不是p之后

13.
智能指针的重载:
1. p // 如果p指向一个对象，返回true；否则False
2.  p == nullptr // 重载为 !p
3. p==q  // 重载为p.get() == q.get()
**使用智能指针管理内存后，不要再用普通指针访问内存。因为此时可能只能指针计数已经为0，,内存被释放。**
**这不是说用智能指针后不能再使用普通指针，而是不要再用普通指针访问内存，可以用普通指针判断是否指向同一对象**
**但为了避免内存被释放，也尽量不要用p.get(),用重载即可**

对于存有智能指针的unordered_set:
1.智能指针重载了==运算符
2.智能指针定义了hash
同样，**智能指针重载了<,>运算符。但是这种比较仅基于普通指针的大小**。没有太大意义，因此尽量避免
对智能指针使用**有序关联**容器(set,map)

## 调试技巧
1. 在调试状态下，调试->windows->调用堆栈，可以查看函数调用层次
